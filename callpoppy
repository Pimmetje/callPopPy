#!/usr/bin/env python
# -*-coding: utf-8 -*-
#
# Copyright 2011 Chris Hastie
#
# Inspired by pyCalledMe by olivier@olihb.com
# http://olihb.com/2010/08/08/incoming-call-popup-under-ubuntu-and-asterisk/
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

 
from twisted.internet import gtk2reactor
gtk2reactor.install(True)
 
from twisted.internet import reactor
from starpy.manager import AMIFactory
from twisted.internet import task
import logging,logging.handlers,sys,os,os.path,stat
from cgi import escape
from pysqlite2 import dbapi2 as sqlite
import ConfigParser

hasGnome = True
try:
  import gnome.ui
except:
  hasGnome = False

appname = 'callpoppy'

# Keep our logs secret
os.umask(0077);

config = ConfigParser.RawConfigParser({
  'port': '5038',
  'uselibnotify': 'False',
  'background': '#171717', 
  'foreground': '#bbbbbb',
  'top': "0",
  'left': "0",
  'x-offset': "0",
  'y-offset': "0",
  'timeout': "6",
  'loglevel': "4",
  'logfile': os.path.expanduser('~/.callpoppy/callpoppy.log')
  })
  
config.optionxform = str
conffile = os.path.expanduser('~/.callpoppy/config')
try:
  config.read(conffile)

  server = config.get('Asterisk', 'server')
  port = config.getint('Asterisk', 'port')
  username = config.get('Asterisk', 'username')
  secret = config.get('Asterisk', 'secret')
  
  loglevel = config.getint('Logging', 'loglevel')
  logfile = config.get('Logging', 'logfile')
  
  popupparams = {}
  popupparams['bg'] = config.get('Popup', 'background')
  popupparams['fg'] = config.get('Popup', 'foreground')
  popupparams['top'] = config.getboolean('Popup', 'top')
  popupparams['left'] = config.getboolean('Popup', 'left')
  popupparams['xoff'] = config.getint('Popup', 'x-offset')
  popupparams['yoff'] = config.getint('Popup', 'y-offset')
  popupparams['timeout'] = config.getint('Popup', 'timeout')
  
  usePyNotify = config.getboolean('Popup', 'uselibnotify')
  
  ext = config.options('Extensions')

  extensions = {}

  for s in ext:
    extensions[s] = config.get('Extensions', s)

except ConfigParser.Error as conferr:
  sys.exit(appname + " could not read the configuration file '" + conffile +"':\n" + conferr.__str__())

# Set up logging
log = logging.getLogger(appname)
loglevels = [logging.CRITICAL, logging.ERROR, logging.WARNING, logging.INFO, logging.DEBUG]
loglevel = loglevel - 1
log.setLevel(loglevels[loglevel])

# create log handler and set level to debug
lh = logging.handlers.RotatingFileHandler(logfile, 'a', 102400, 3)
lh.setLevel(logging.DEBUG)

logformat = logging.Formatter('%(name)s: %(asctime)s %(levelname)s %(message)s')
lh.setFormatter(logformat)

log.addHandler(lh)

sqlconnection = sqlite.connect(os.path.expanduser('~/.callpoppy/numbers.db'))

cursor = sqlconnection.cursor()
 
timeouttask=None
timeoutping=5
timeoutloop=120

class callPopFactory(AMIFactory):
    cbconnect=None
    def __init__(self):
        AMIFactory.__init__(self, username, secret)
    def connect(self):
        log.info("Connecting to Asterisk")
        df = self.login(server, port)
        if self.cbconnect!=None:
            df.addCallback(self.cbconnect)
    def clientConnectionLost(self,connector,reason):
        log.warning("connection lost - connecting again: " + reason.__str__())
        reactor.callLater(1,self.connect)
    def clientConnectionFailed(self,connector,reason):
        log.warning("connection failed - connecting again: " + reason.__str__())
        reactor.callLater(1,self.connect)

class Popup:
  def __init__(self, usePyNotify, params):
    self.timeout = params['timeout']
    self.usePyNotify = usePyNotify

    if self.usePyNotify:
      try:
        log.debug("Attempting to use pynotify")
        import pynotify
        self.notifier = pynotify
        self.notifier.init(appname)
      except:
        log.warning("Unable to import pynotify. Using gtkPopupNotify instead")
        self.usePyNotify = False
    
    if not self.usePyNotify:
      log.debug("Importing gtkPopupNotify")
      import gtkPopupNotify, gtk
      for k in params.keys():
        log.debug("Popup param '" + k + "': " +params[k].__str__())
      self.notifier=gtkPopupNotify.NotificationStack(timeout=self.timeout)
      self.notifier.show_timeout = False
      self.notifier.edge_offset_x = params['xoff']
      self.notifier.edge_offset_y = params['yoff']
      self.notifier.corner = params['left'],params['top']
      self.notifier.max_popups = 1
      self.notifier.bg_color = gtk.gdk.Color(params['bg'])
      self.notifier.fg_color = gtk.gdk.Color(params['fg'])
      self.notifier.fontdesc = ("Sans Bold 10", "Sans 10", "Sans 10")

  def show(self, title, message):
    log.debug("Popup.show called")
    if self.usePyNotify:
      log.debug("Notifying with pynotifier")
      n=self.notifier.Notification(title,message,"call-start")
      n.set_timeout(self.timeout * 1000)
      n.show()
    else:
      log.debug("Notifying with gtkPopupNotify")
      self.notifier.new_popup(title=escape(title), message=escape(message), image=os.path.join(sys.path[0], 'call-start.png'))
    return True

def onDial(protocol,event):
    if 'destination' in event:
      destination=event['destination']
      for s in extensions.keys():
        if destination.startswith(s):
          cid=event['calleridnum']
          cidname=lookupnumber(cid,event['calleridname'])
          extname=extensions[s]
          log.info("Call from " + cidname + " (" + cid + ") for " + extname)
          popup.show("Incoming call for "+extname, cidname + "\n"+cid)

def lookupnumber(cidnum, out):
    global cursor
    idx = cidnum[-10:]
    try:
      cursor.execute('SELECT name FROM numbers WHERE tel = ?', (idx,))
      row = cursor.fetchone()
    except:
      log.debug("Number not found in database")
      return out
    if row:
      out = row[0]
    return out

def checknetlink(protocol):
 
    def ontimeout():
        log.debug("timeout")
        if dc.active():
            dc.cancel()
        timeouttask.stop()
        protocol.transport.loseConnection()
 
    def canceltimeout(*val):
        if dc.active():
            dc.cancel()
 
        log.debug("cancel timeout")
        log.debug(val)
 
    def success(val):
        pass
 
    log.debug("setting timeout")
    dc = reactor.callLater(timeoutping,ontimeout)
    df = protocol.ping()
    df.addBoth(canceltimeout)
    df.addCallback(success)
    df.addErrback(ontimeout)
 
def onLogin(protocol):
    df = protocol.registerEvent("Dial",onDial)
    global timeouttask
    timeouttask = task.LoopingCall(checknetlink,protocol)
    timeouttask.start(timeoutloop);
    return df
 
def main():
    cp = callPopFactory()
    logging.getLogger('AMI').addHandler(lh)
    cp.cbconnect=onLogin
    cp.connect()
 
def killapp(*args):
    reactor.stop()
    return True
 
if __name__ == '__main__':

    # initialise our notifier
    popup = Popup(usePyNotify, popupparams)

    # On Gnome, ensure the script exits when the user 
    # logs out.
    if hasGnome:
      gnome.program_init (appname, "1.0")
      client = gnome.ui.master_client()
      client.connect("save-yourself", killapp)


    reactor.callWhenRunning(main)
    reactor.run()
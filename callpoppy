#!/usr/bin/env python
# -*-coding: utf-8 -*-
#
# Copyright 2011 Chris Hastie
#
# Inspired by pyCalledMe by olivier@olihb.com
# http://olihb.com/2010/08/08/incoming-call-popup-under-ubuntu-and-asterisk/
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

 
from twisted.internet import gtk2reactor
gtk2reactor.install(True)
 
from twisted.internet import reactor
from starpy.manager import AMIFactory
from twisted.internet import task
import logging,logging.handlers,sys,os.path
from cgi import escape
from pysqlite2 import dbapi2 as sqlite
import ConfigParser
import logging.config


hasGnome = True
try:
  import gnome.ui
except:
  hasGnome = False

appname = 'callpoppy'

config = ConfigParser.RawConfigParser({
  'port': '5038',
  'uselibnotify': 'False',
  'background': '#171717', 
  'foreground': '#bbbbbb',
  'top': "0",
  'left': "0",
  'x-offset': "0",
  'y-offset': "0",
  'timeout': "6",
  'loglevel': "4",
  'logfile': os.path.expanduser('~/.callpoppy/callpoppy.log')
  })
  
config.optionxform = str
try:
  config.read(os.path.expanduser('~/.callpoppy/config'))

  server = config.get('Asterisk', 'server')
  port = config.getint('Asterisk', 'port')
  username = config.get('Asterisk', 'username')
  secret = config.get('Asterisk', 'secret')
  
  loglevel = config.getint('Logging', 'loglevel')
  logfile = config.get('Logging', 'logfile')
  
  pu_bg = config.get('Popup', 'background')
  pu_fg = config.get('Popup', 'foreground')
  pu_top = config.getboolean('Popup', 'top')
  pu_left = config.getboolean('Popup', 'left')
  pu_xoff = config.getint('Popup', 'x-offset')
  pu_yoff = config.getint('Popup', 'y-offset')
  pu_timeout = config.getint('Popup', 'timeout')
  
  usePyNotify = config.getboolean('Popup', 'uselibnotify')
  
  ext = config.options('Extensions')

  extensions = {}

  for s in ext:
    extensions[s] = config.get('Extensions', s)

except ConfigParser.Error as conferr:
  print "Couldn't start: " + conferr.__str__()
  sys.exit(1)

# Set up logging
log = logging.getLogger(appname)
loglevels = [logging.CRITICAL, logging.ERROR, logging.WARNING, logging.INFO, logging.DEBUG]
loglevel = loglevel - 1
log.setLevel(loglevels[loglevel])

# create log handler and set level to debug
lh = logging.handlers.RotatingFileHandler(logfile, 'a', 102400, 3)
lh.setLevel(logging.DEBUG)

logformat = logging.Formatter('%(name)s: %(levelname)s %(message)s')
lh.setFormatter(logformat)

log.addHandler(lh)

if usePyNotify:
  try:
    log.debug("Attempting to use pynotify")
    import pynotify
  except:
    log.warning("Unable to import pynotify. Using gtkPopupNotify instead")
    usePyNotify = False

if not usePyNotify:
  log.debug("Importing gtkPopupNotify")
  import gtkPopupNotify, gtk

sqlconnection = sqlite.connect(os.path.expanduser('~/.callpoppy/numbers.db'))

cursor = sqlconnection.cursor()
 
timeouttask=None
timeoutping=5
timeoutloop=120

class callMeFactory(AMIFactory):
    cbconnect=None
    def __init__(self):
        AMIFactory.__init__(self, username, secret)
    def connect(self):
        log.info("Connecting to Asterisk")
        df = self.login(server, port)
        if self.cbconnect!=None:
            df.addCallback(self.cbconnect)
    def clientConnectionLost(self,connector,reason):
        log.warning("connection lost - connecting again: " + reason.__str__())
        reactor.callLater(1,self.connect)
    def clientConnectionFailed(self,connector,reason):
        log.warning("connection failed - connecting again: " + reason.__str__())
        reactor.callLater(1,self.connect)


def onDial(protocol,event):
    if 'destination' in event:
      destination=event['destination']
      for s in extensions.keys():
        if destination.startswith(s):
          cid=event['calleridnum']
          cidname=lookupnumber(cid,event['calleridname'])
          extname=extensions[s]
          log.info("Call from " + cidname + " (" + cid + ") for " + extname)
          notify("Incoming call for "+extname, cidname + "\n"+cid)

def lookupnumber(cidnum, out):
    global cursor
    idx = cidnum[-10:]
    try:
      cursor.execute('SELECT name FROM numbers WHERE tel = ?', (idx,))
      row = cursor.fetchone()
    except:
      log.debug("Number not found in database")
      return out
    if row:
      out = row[0]
    return out

def initnotifier():
  if usePyNotify:
    pynotify.init(appname)
    return None
  else:
    notifier=gtkPopupNotify.NotificationStack(timeout=pu_timeout)
    notifier.show_timeout = False
    notifier.edge_offset_x = pu_xoff
    notifier.edge_offset_y = pu_yoff
    notifier.corner = pu_left,pu_top
    notifier.max_popups = 1
    notifier.bg_color = gtk.gdk.Color(pu_bg)
    notifier.fg_color = gtk.gdk.Color(pu_fg)
    notifier.fontdesc = ("Sans Bold 10", "Sans 10", "Sans 10")
    return notifier

def notify(title, message):
  log.debug("notify called")
  if usePyNotify:
    log.debug("Notifying with pynotifier")
    n=pynotify.Notification(title,message,"call-start")
    n.set_timeout(pu_timeout * 1000)
    n.show()
  else:
    log.debug("Notifying with gtkPopupNotify")
    notifier.new_popup(title=escape(title), message=escape(message), image="call-start.png")
  log.debug("returning from notify")
  return True

def checknetlink(protocol):
 
    def ontimeout():
        log.debug("timeout")
        if dc.active():
            dc.cancel()
        timeouttask.stop()
        protocol.transport.loseConnection()
 
    def canceltimeout(*val):
        if dc.active():
            dc.cancel()
 
        log.debug("cancel timeout")
        log.debug(val)
 
    def success(val):
        pass
 
    log.debug("setting timeout")
    dc = reactor.callLater(timeoutping,ontimeout)
    df = protocol.ping()
    df.addBoth(canceltimeout)
    df.addCallback(success)
    df.addErrback(ontimeout)
 
def onLogin(protocol):
    df = protocol.registerEvent("Dial",onDial)
    global timeouttask
    timeouttask = task.LoopingCall(checknetlink,protocol)
    timeouttask.start(timeoutloop);
    return df
 
def main():
    cm = callMeFactory()
    logging.getLogger('AMI').addHandler(lh)
    cm.cbconnect=onLogin
    cm.connect()
 
def killapp(*args):
    reactor.stop()
    return True
 
if __name__ == '__main__':
    #manager.log.setLevel( logging.DEBUG )
    #log.setLevel(logging.INFO)
    #logging.basicConfig()

    # initialise our notifier
    notifier = initnotifier()

    # On Gnome, ensure the script exits when the user 
    # logs out.
    if hasGnome:
      gnome.program_init (appname, "1.0")
      client = gnome.ui.master_client()
      client.connect("save-yourself", killapp)


    reactor.callWhenRunning(main)
    reactor.run()